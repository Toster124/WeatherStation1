#include <SPI.h>
#include <VirtualWire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>
#include <LowPower.h>
#include <GyverTimer.h>

#define PIN        3
#define MW         8
#define MH         8
#define BRIGHTNESS 150

#define MATRIX_VCC 2
#define RADIO_VCC 3

boolean sleep;
int sleep_count, diode[2];
byte num[50];

GTimer_ms myTimer;
Adafruit_NeoMatrix *matrix = new Adafruit_NeoMatrix(MW, MH, PIN,
  NEO_MATRIX_BOTTOM + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
  NEO_GRB + NEO_KHZ800);

static const uint16_t PROGMEM RGB_bmp[][64] = {
  // 0: 01
 {0x0FF, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x0FF,
  0x000, 0x0FF, 0x000, 0x0FF, 0x0FF, 0x000, 0x0FF, 0x000, 
  0x000, 0x000, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x000, 0x000, 
  0x000, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x000, 
  0x000, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x000, 
  0x000, 0x000, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x000, 0x000, 
  0x000, 0x0FF, 0x000, 0x0FF, 0x0FF, 0x000, 0x0FF, 0x000, 
  0x0FF, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x0FF,
},
  // 1: 02
{ 0x000, 0x000, 0x000, 0x000, 0x000, 0x0FF, 0x0FF, 0x0FF, 
  0x000, 0x000, 0x880, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 
  0x000, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 
  0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, },
  // 2: 03
{ 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 
  0x000, 0x000, 0x880, 0xFF0, 0x880, 0x000, 0x000, 0x000, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x000, 0x000, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 0x000, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, },
// 3: 04
 {0x000, 0x000, 0x000, 0x000, 0x000, 0xF00, 0xF00, 0xF00, 
  0x000, 0x000, 0x880, 0xFF0, 0xF00, 0xF00, 0xF00, 0xF00, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x000, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 
  0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, },
// 4: 09
{ 0x000, 0x000, 0x880, 0xFF0, 0xF00, 0xF00, 0xF00, 0xF00, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x000, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00,
  0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000,
  0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000,},
// 5: 10
 {0x000, 0x000, 0x880, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 
  0x000, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 
  0x880, 0xFF0, 0xF00, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00,
  0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000,
  0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000,},
// 6: 11
 {0x000, 0x000, 0x880, 0xFF0, 0xF00, 0xF00, 0xF00, 0xF00, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x000, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0x000, 0x0FF, 0x000, 0x000, 0x000, 0x0FF, 0x000,
  0x000, 0x0FF, 0x0FF, 0x000, 0x000, 0x0FF, 0x0FF, 0x000,
  0x0FF, 0x0FF, 0x000, 0x000, 0x0FF, 0x0FF, 0x000, 0x000,},
// 7: 13
 { 0xFFF, 0x000, 0x000, 0xFFF, 0xFFF,0x000, 0x000, 0xFFF,
  0x000, 0xFFF, 0x000, 0xFFF, 0xFFF, 0x000, 0xFFF, 0x000,
  0x000, 0x000, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0x000, 0x000,
  0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF,
  0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF,
  0x000, 0x000, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0x000, 0x000,
  0x000, 0xFFF, 0x000, 0xFFF, 0xFFF, 0x000, 0xFFF, 0x000,
  0xFFF, 0x000, 0x000, 0xFFF, 0xFFF, 0x000, 0x000, 0xFFF, },
// 8: 50
 {0x222, 0x222, 0x222, 0x222, 0x222, 0x222, 0x222, 0x222, 
  0x222, 0x222, 0x222, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 
  0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0x222, 0x222, 0x222, 
  0x222, 0x222, 0x222, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 
  0x222, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0x222, 0x222, 0x222, 
  0x222, 0x222, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 
  0x222, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0x222, 0x222, 
  0x222, 0x222, 0x222, 0x222, 0x222, 0x222, 0x222, 0x222,},
};
void setup() {
  pinMode(MATRIX_VCC, OUTPUT);
  pinMode(RADIO_VCC, OUTPUT);
  for (int i = 0; i != 3; i++) {
    pinMode(diode[i], OUTPUT);
  }
  digitalWrite(MATRIX_VCC, 1);
  digitalWrite(RADIO_VCC, 1);
  matrix->begin();
  matrix->setBrightness(BRIGHTNESS);
  matrix->show();
  vw_set_ptt_inverted(true);
  vw_setup(2000); 
  vw_rx_start();
  myTimer.setInterval(5000);   // настроить интервал
  myTimer.setMode(MANUAL);
  myTimer.reset();
  myTimer.start();
  for (int i = 0; i != 3; i++) {
    digitalWrite(diode[i], 1);
    delay(200);
    digitalWrite(diode[i], 0);
  }
num[1] = 0;
num[2] = 1;
num[3] = 2;
num[4] = 3;
num[9] = 4;
num[10] = 5;
num[11] = 6;
num[13] = 7;
num[50] = 8;
}

void loop() {
  uint8_t buf[VW_MAX_MESSAGE_LEN];
  uint8_t buflen = VW_MAX_MESSAGE_LEN;
  for (int i = 0; i != 3; i++) {
    display_rgbBitmap(num[buf[i]]);
    digitalWrite(diode[i], 1);
    while(!myTimer.isReady() && !vw_get_message(buf, &buflen)) {}
    digitalWrite(diode[i], 0);
    myTimer.reset();
    myTimer.start();
    if (vw_get_message(buf, &buflen)){break;}
  }
    if (vw_get_message(buf, &buflen)){
      if (buf[0] = 228){
      sleep = 1;
      }}
    if (sleep) {
  digitalWrite(MATRIX_VCC, 0);
  digitalWrite(RADIO_VCC, 0);
  for (int i = 0; i != 3; i++) {
    digitalWrite(diode[i], 0);
  }
LowPower.powerDown(SLEEP_8S, ADC_OFF, BOD_OFF);      // спать 8 сек. mode POWER_OFF, АЦП выкл
 sleep_count++;            // +1 к счетчику просыпаний
  if (sleep_count >= 3150) {  // если время сна превысило 7 часов
    sleep = 0;          // рарешить выполнение расчета
    sleep_count = 0;        // обнулить счетчик
    delay(2);               // задержка для стабильности
  }}
}
void fixdrawRGBBitmap(int16_t x, int16_t y, const uint16_t *bitmap, int16_t w, int16_t h) {
  uint16_t RGB_bmp_fixed[w * h];
  for (uint16_t pixel = 0; pixel < w * h; pixel++) {
    uint8_t r, g, b;
    uint16_t color = pgm_read_word(bitmap + pixel);
    b = (color & 0xF00) >> 8;
    g = (color & 0x0F0) >> 4;
    r = color & 0x00F;
    b = map(b, 0, 15, 0, 31);
    g = map(g, 0, 15, 0, 63);
    r = map(r, 0, 15, 0, 31);
    RGB_bmp_fixed[pixel] = (r << 11) + (g << 5) + b;
  }
  matrix->drawRGBBitmap(x, y, RGB_bmp_fixed, w, h);
}

void display_rgbBitmap(uint8_t bmp_num) {
  static uint16_t bmx, bmy;
  fixdrawRGBBitmap(bmx, bmy, RGB_bmp[bmp_num], 8, 8);
  bmx += 8;
  if (bmx >= MW) {bmx = 0;}
  if (!bmx) {bmy += 8;}
  if (bmy >= MH) {bmy = 0;}
  matrix->show();
}
