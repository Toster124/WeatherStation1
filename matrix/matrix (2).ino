#include <SPI.h>
#include <iarduino_RF433_Receiver.h>  
#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>
#include <LowPower.h>
byte j[11];


#define PIN        6
#define MW         8
#define MH         8
#define BRIGHTNESS 150

#define MATRIX_VCC 8

byte num[51];
iarduino_RF433_Receiver    radioRX(2);

Adafruit_NeoMatrix *matrix = new Adafruit_NeoMatrix(MW, MH, PIN,
  NEO_MATRIX_BOTTOM + NEO_MATRIX_RIGHT + NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
  NEO_GRB + NEO_KHZ800);

static const uint16_t PROGMEM RGB_bmp[][64] = {
  // 0: 01
 {0x0FF, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x0FF,
  0x000, 0x0FF, 0x000, 0x0FF, 0x0FF, 0x000, 0x0FF, 0x000, 
  0x000, 0x000, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x000, 0x000, 
  0x000, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x000, 
  0x000, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x000, 
  0x000, 0x000, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 0x000, 0x000, 
  0x000, 0x0FF, 0x000, 0x0FF, 0x0FF, 0x000, 0x0FF, 0x000, 
  0x0FF, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x0FF,
},
  // 1: 02
{ 0x000, 0x000, 0x000, 0x000, 0x000, 0x0FF, 0x0FF, 0x0FF, 
  0x000, 0x000, 0x880, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 
  0x000, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 
  0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, },
  // 2: 03
{ 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 
  0x000, 0x000, 0x880, 0xFF0, 0x880, 0x000, 0x000, 0x000, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x000, 0x000, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 0x000, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, },
// 3: 04
 {0x000, 0x000, 0x000, 0x000, 0x000, 0xF00, 0xF00, 0xF00, 
  0x000, 0x000, 0x880, 0xFF0, 0xF00, 0xF00, 0xF00, 0xF00, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x000, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 
  0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, },
// 4: 09
{ 0x000, 0x000, 0x880, 0xFF0, 0xF00, 0xF00, 0xF00, 0xF00, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x000, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00,
  0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000,
  0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000,},
// 5: 10
 {0x000, 0x000, 0x880, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 0x0FF, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 
  0x000, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 0x0FF, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x0FF, 0x0FF, 
  0x880, 0xFF0, 0xF00, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00,
  0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000,
  0x000, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x000,},
// 6: 11
 {0x000, 0x000, 0x880, 0xFF0, 0xF00, 0xF00, 0xF00, 0xF00, 
  0x000, 0x880, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x000, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xF00, 0xF00, 
  0x880, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0xFF0, 0x880, 
  0x000, 0x000, 0x0FF, 0x000, 0x000, 0x000, 0x0FF, 0x000,
  0x000, 0x0FF, 0x0FF, 0x000, 0x000, 0x0FF, 0x0FF, 0x000,
  0x0FF, 0x0FF, 0x000, 0x000, 0x0FF, 0x0FF, 0x000, 0x000,},
// 7: 13
 { 0xFFF, 0x000, 0x000, 0xFFF, 0xFFF,0x000, 0x000, 0xFFF,
  0x000, 0xFFF, 0x000, 0xFFF, 0xFFF, 0x000, 0xFFF, 0x000,
  0x000, 0x000, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0x000, 0x000,
  0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF,
  0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF,
  0x000, 0x000, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0x000, 0x000,
  0x000, 0xFFF, 0x000, 0xFFF, 0xFFF, 0x000, 0xFFF, 0x000,
  0xFFF, 0x000, 0x000, 0xFFF, 0xFFF, 0x000, 0x000, 0xFFF, },
// 8: 50
 {0x222, 0x222, 0x222, 0x222, 0x222, 0x222, 0x222, 0x222, 
  0x222, 0x222, 0x222, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 
  0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0x222, 0x222, 0x222, 
  0x222, 0x222, 0x222, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 
  0x222, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0x222, 0x222, 0x222, 
  0x222, 0x222, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 
  0x222, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0x222, 0x222, 
  0x222, 0x222, 0x222, 0x222, 0x222, 0x222, 0x222, 0x222,},
};
void setup() {
  Serial.begin(9600);
  for(int i = 0; i <= 10; i++) {
    j[i] = 1;
  }
  pinMode(MATRIX_VCC, OUTPUT);
    radioRX.begin(1000);                                  // Инициируем работу приёмника MX-RM-5V (в качестве параметра можно указать скорость ЧИСЛО бит/сек, тогда можно не вызывать функцию setDataRate)
    radioRX.openReadingPipe (5);                          // Открываем 5 трубу для приема данных (если вызвать функцию без параметра, то будут открыты все трубы сразу, от 0 до 7)
    radioRX.startListening  ();  
    pinMode(A2, INPUT);  
    pinMode(A3, OUTPUT);
    pinMode(A4, OUTPUT);
    pinMode(A5, OUTPUT);
  digitalWrite(MATRIX_VCC, 1);
  matrix->begin();
  byte new_bright = map(analogRead(A2), 1100, 1, 3, 255);
  matrix->setBrightness(new_bright);
  matrix->show();

num[1] = 0;
num[2] = 1;
num[3] = 2;
num[4] = 3;
num[9] = 4;
num[10] = 5;
num[11] = 6;
num[13] = 7;
num[50] = 8;
}

void loop() {
  byte new_bright = map(analogRead(A2), 1040, 20, 0, 255);
  Serial.println(new_bright);
  matrix->setBrightness(new_bright);
  if(radioRX.available()){
       radioRX.read(j, sizeof(j)); 
       for(int i = 0; i != sizeof(j); i++) {
       Serial.println(j[i]);                                   // Выводим полученные данные на монитор
       }}
    Serial.println("------------------------------------");
    byte lol = j[0];
    display_rgbBitmap(num[lol]);
    digitalWrite(A5, 0);
    digitalWrite(A3, 1);
    Serial.println(lol);
    delay(2000);
    lol = j[2];
    display_rgbBitmap(num[lol]);
    digitalWrite(A3, 0);
    digitalWrite(A4, 1);
    Serial.println(lol);
    delay(2000);
    lol = j[9];
    display_rgbBitmap(num[lol]);
    digitalWrite(A4, 0);
    digitalWrite(A5, 1);
    Serial.println(lol);
    delay(2000);
    
    
    

}
void fixdrawRGBBitmap(int16_t x, int16_t y, const uint16_t *bitmap, int16_t w, int16_t h) {
  uint16_t RGB_bmp_fixed[w * h];
  for (uint16_t pixel = 0; pixel < w * h; pixel++) {
    uint8_t r, g, b;
    uint16_t color = pgm_read_word(bitmap + pixel);
    b = (color & 0xF00) >> 8;
    g = (color & 0x0F0) >> 4;
    r = color & 0x00F;
    b = map(b, 0, 15, 0, 31);
    g = map(g, 0, 15, 0, 63);
    r = map(r, 0, 15, 0, 31);
    RGB_bmp_fixed[pixel] = (r << 11) + (g << 5) + b;
  }
  matrix->drawRGBBitmap(x, y, RGB_bmp_fixed, w, h);
}

void display_rgbBitmap(uint8_t bmp_num) {
  static uint16_t bmx, bmy;
  fixdrawRGBBitmap(bmx, bmy, RGB_bmp[bmp_num], 8, 8);
  bmx += 8;
  if (bmx >= MW) {bmx = 0;}
  if (!bmx) {bmy += 8;}
  if (bmy >= MH) {bmy = 0;}
  matrix->show();
}
